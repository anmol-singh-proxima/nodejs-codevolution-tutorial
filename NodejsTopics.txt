1. ECMAScript
- ECMAScript is the Core of Javascript
- Javascript = ECMAScript + APIs + other features
- It started in 1996 as a ECMAScript Standard
- There are 6 versions of ECMAScript
    - ECMAScript 1 - 1997
    - ECMAScript 2 - 1998
    - ECMAScript 3 - 1999
    - ECMAScript 4 - Never Released
    - ECMAScript 5 - 2009
    - ECMAScript 6 - 2015 (ES6)


2. V8 Javascript Engine
- A Javascript engine helps in compiling and executing of a Javascript program
- One such engine is V8 Engine which is written in C++, and it is developed by Google and used in Google Chrome


3. Javascript Runtime
- A Javascript Runtime is an environment which provides all the neccessary components in order to use and run a Javascript program
- Chrome contains one such Javascript Runtime
- Chrome Javascript Runtime contains
    - V8 Javascript Engine
        - Memory - Heap Memory to store the variables in a Javascript program
        - Call Stack - To run Javascript program
    - Web Browser APIs
        - DOM
        - Storage
        - Promises
        - Timers
    - Queue
        - Before any async task gets executed in JS, it waits in the Queue
        - 2 kinds of Queue:
            - Microstack Queue
            - Callback/Task Queue
    - Event Loop
        - It makes sure the async task gets executed in the right order
 

4. Nodejs
- Nodejs is an open-source, cross-platform Javascript Runtime environment
- It is not a language and not even a framework
- It is capable of executing Javascript code outside the Browser
- It can execute not only the Standard ECMAScript languagebut also new features that are available through C++ bindings using the V8 Engine
- It consists of C++ files which form the core features and Javascript files which expose common utilities and some of the C++ features for easier consumption
- It is used to build complex and powerful applications
- Nodejs Runtime contains:
    - Dependencies - V8, libuc, zlib, etc
    - C/C++ Features
    - JS Library
- There are 2 ways to execute Javascript in Nodejs:
    - REPL (Read Evaluate Print Loop)
    - Put the code in a Javascript file and run it in terminal


5. Browser Vs Nodejs
- Browser contains DOM, Web Platform APIs like cookies, and objects like document and window whereas Nodejs contains APIs like filesystem access functionality
- With Nodejs, you control the environment, whereas with a Browser, users have the control


=================
==== MODULES ====
=================

What is module?
- A module is an encapsulated and reusable chunk of code that has its own context
- In Nodejs, each file is a module that is isolated by default
- To load a module into another file, we use require() function
- When the main file is executed, the code in the module is also executed
- If a file we are requiring is a Javascript file, then we can skip specifying the .js extension and nodejs will infer it on our behalf

There are 3 types of Modules:
- Local Modules - Modules that we create as a developer in our application
- Built-in Modules - Modules that Nodejs ships with out of the box
- Third party Modules - Modules created by other developers that we can use in out application

CommonJS
- It is a standard that states how a module should be structured and shared
- Each file is treated as a module
- Variables, functions, objects are not accessible to other files by default
- Explicitly tell the module system which parts of the code to be exported by using module.exports or exports
- To import code into a file, use the require() function
- File extension for this module system is '.js'

Module Scope
- Each module has its own private scope so 2 modules containing same variable-name or function-name imported in one Javascript file does not create conflict
- It is done by using IIFE(Immediately Invoked Function Expression)

Module Wrapper
- Nodejs wraps each module with an IIFE with 5 parameters:
    - exports
    - require
    - module
    - __dirname
    - __filename

Module Caching
- Suppose a module contains a class and its exporting object (or instance) of the class
- Then whenever the module is imported (or called) into a file for the first time, the instance of the class will get cached or saved
- Then if we call the same module again in the file, nodejs will return the same reference to the instance of the class in the module which has been cached
- It creates a problem when we want a new instance of the same class from the imported module in the file
- To solve this, we can export the class itself in the file and then create different instances based on our requirements


Module Import and Export Patterns
- There are 5 types of Patterns for importing and exporting modules:
1.  Export: const funcName = () => {};
            module.exports = funcName;
    Import: const funcName = require('./moduleName);
2.  Export: module.exports = () => {};
    Import: const funcName = require('./moduleName);
3.  Export: const funcName1 = () => {};
            const funcName2 = () => {};
            module.exports = { funcName1, funcName2 };
    Import: const moduleName = require('./moduleName);
            const { funcName1, funcName2 } = moduleName;
4.  Export: module.exports.funcName1 = () => {};
            module.exports.funcName2 = () => {};
    Import: const moduleName = require('./moduleName);
            const { funcName1, funcName2 } = moduleName;
5.  Export: exports.funcName = () => {};
    Import: const funcName = require('./moduleName);
- Always use module.exports instead of only exports because it creates a barrier in these two objects leading to errors in importing the functions from the module
