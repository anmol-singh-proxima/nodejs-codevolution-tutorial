=======================================
======== Javascript and NodeJS ========
=======================================

1. ECMAScript
- ECMAScript is the Core of Javascript
- Javascript = ECMAScript + APIs + other features
- It started in 1996 as a ECMAScript Standard
- There are 6 versions of ECMAScript
    - ECMAScript 1 - 1997
    - ECMAScript 2 - 1998
    - ECMAScript 3 - 1999
    - ECMAScript 4 - Never Released
    - ECMAScript 5 - 2009
    - ECMAScript 6 - 2015 (ES6)


2. V8 Javascript Engine
- A Javascript engine helps in compiling and executing of a Javascript program
- One such engine is V8 Engine which is written in C++, and it is developed by Google and used in Google Chrome


3. Javascript Runtime
- A Javascript Runtime is an environment which provides all the neccessary components in order to use and run a Javascript program
- Chrome contains one such Javascript Runtime
- Chrome Javascript Runtime contains
    - V8 Javascript Engine
        - Memory - Heap Memory to store the variables in a Javascript program
        - Call Stack - To run Javascript program
    - Web Browser APIs
        - DOM
        - Storage
        - Promises
        - Timers
    - Queue
        - Before any async task gets executed in JS, it waits in the Queue
        - 2 kinds of Queue:
            - Microstack Queue
            - Callback/Task Queue
    - Event Loop
        - It makes sure the async task gets executed in the right order
 

4. Nodejs
- Nodejs is an open-source, cross-platform Javascript Runtime environment
- It is not a language and not even a framework
- It is capable of executing Javascript code outside the Browser
- It can execute not only the Standard ECMAScript languagebut also new features that are available through C++ bindings using the V8 Engine
- It consists of C++ files which form the core features and Javascript files which expose common utilities and some of the C++ features for easier consumption
- It is used to build complex and powerful applications
- Nodejs Runtime contains:
    - Dependencies - V8, libuc, zlib, etc
    - C/C++ Features
    - JS Library
- There are 2 ways to execute Javascript in Nodejs:
    - REPL (Read Evaluate Print Loop)
    - Put the code in a Javascript file and run it in terminal


5. Browser Vs Nodejs
- Browser contains DOM, Web Platform APIs like cookies, and objects like document and window whereas Nodejs contains APIs like filesystem access functionality
- With Nodejs, you control the environment, whereas with a Browser, users have the control


=========================
======== MODULES ========
=========================

1. What is a Module?
- A module is an encapsulated and reusable chunk of code that has its own context
- In Nodejs, each file is a module that is isolated by default
- To load a module into another file, we use require() function
- When the main file is executed, the code in the module is also executed
- If a file we are requiring is a Javascript file, then we can skip specifying the .js extension and nodejs will infer it on our behalf


2. Types of Modules
- Local Modules - Modules that we create as a developer in our application
- Built-in Modules - Modules that Nodejs ships with out of the box
- Third party Modules - Modules created by other developers that we can use in out application


3. CommonJS
- It is a standard that states how a module should be structured and shared
- This is the first (or default) Module System included in Nodejs
- Each file is treated as a module
- Variables, functions, objects are not accessible to other files by default
- Explicitly tell the module system which parts of the code to be exported by using module.exports or exports
- To import code into a file, use the require() function
- File extension for this module system is '.js'


4. Module Scope
- Each module has its own private scope so 2 modules containing same variable-name or function-name imported in one Javascript file does not create conflict
- It is done by using IIFE(Immediately Invoked Function Expression)


5. Module Wrapper
- Nodejs wraps each module with an IIFE which receives 5 parameters:
    - exports
    - require
    - module
    - __dirname
    - __filename


6. Module Caching
- Suppose a module contains a class and its exporting object (or instance) of the class
- Then whenever the module is imported (or called) into a file for the first time, the instance of the class will get cached or saved
- Then if we call the same module again in the file, nodejs will return the same reference to the instance of the class in the module which has been cached
- It creates a problem when we want a new instance of the same class from the imported module in the file
- To solve this, we can export the class itself in the file and then create different instances based on our requirements


7. Module Import and Export Patterns in CommonJS
- There are 5 types of Patterns for importing and exporting modules:
    1.  Export: const funcName = () => {};
                module.exports = funcName;
        Import: const funcName = require('./moduleName);
    2.  Export: module.exports = () => {};
        Import: const funcName = require('./moduleName);
    3.  Export: const funcName1 = () => {};
                const funcName2 = () => {};
                module.exports = { funcName1, funcName2 };
        Import: const moduleName = require('./moduleName);
                const { funcName1, funcName2 } = moduleName;
    4.  Export: module.exports.funcName1 = () => {};
                module.exports.funcName2 = () => {};
        Import: const moduleName = require('./moduleName);
                const { funcName1, funcName2 } = moduleName;
    5.  Export: exports.funcName = () => {};
        Import: const funcName = require('./moduleName);
- Always use module.exports instead of only exports because it creates a barrier in these two objects leading to errors in importing the functions from the module


8. ES Modules
- ES Modules is the ECMAScript standard for Modules
- It is also known as ECMAScript Modules, short for ES Modules or ESM
- It was introduced with ES6 and got included in Nodejs 14 and above
- Instead of module.exports, we use the 'export' keyword
- An export can be default or named
- We import the exported variables and functions using 'import' keyword
- If it is a default export, we can assign any name while exporting
- If it is a names export, the import name must be the same
- The extension for the module is '.mjs' and this module can be imported only in a file with '.mjs' extension
- The import and export formats in ESM are:
    1.  Export: const funcName = () => {};
                export default funcName;
        Import: import funcName from 'moduleName';
    2.  Export: export default () => {};
        Import: import funcName from 'moduleName';
    3.  Export: const funcName1 = () => {};
                const funcName2 = () => {};
                export default { funcName1, funcName2 }
        Import: import moduleName from 'moduleName'
                const { funcName1, funcName2 } = moduleName;
    4.  Export: export const funcName1 () => {};
                export const funcName2 () => {};
        Import: import * as moduleName from 'moduleName';
                const { funcName1, funcName2 } = moduleName;
                OR
                import { funcName1, funcName2 } from 'moduleName'


9. Importing JSON
- Importing Json file similar to importing a module
    - const data = require('[json_file]')
- Then this data can be used as either an object or an array based on the data stored in json_file.


10. Built-in Modules
- Modules that are shipped with Nodejs
- These are also referred as Core modules
- Need to import the modules before using them in our files
- The 5 common Built-in modules are:
    - path
    - events
    - fs
    - stream
    - http
- To import Built-in modules, we need to prefix the name of module with 'node:' in require(), but 'node:' prefix is optional
    - const module = require('node:[module_name]')
- node: Protocol
    - Makes it perfectly clear that import is a Nodejs built-in module
    - Makes the import identifier a valid absolute URL
    - Avoids conflicts for future Nodejs biult-in modules


11. Built-in Module: path
- It is a module which provides utilities to work with files, directories and paths
- There are a few methods in it:
    - path.basename("[path]")
    - path.extname("[file/dir/path]")
    - path.parse("[file/dir/path]")
    - path.format(path.parse("[file/dir/path]"))
    - path.isAbsolute("[path]")
    - path.join("[file/dir/path]", "[file/dir/path]", ...)
    - path.resolve("[file/dir/path]", "[file/dir/path]", ...)


12. Callbacks
- In Javascript, functions are first class objects
- A function can be passed as an argument to a function
- A function can also be returned as values from other function
- Callback Function - A function which is passed as argument or returned as values from other function is called a callBack function
- Higher Order Function - A function to which a callBack is passed as an argument is called a Higher Order Function
    function callBack () {}
    higherOrderFunction(callBack) {
        ...
        callBack()
    }
- 2 Types of Callbacks:
    - Synchronous Callback
    - Asynchronous Callback
- Synchronous Callback
    - A callBack which is executed immediately is called a Synchronous Callback
- Asynchronous Callback
    - A callBack that is often used to continue or resume code execution after an asynchronous operation has completed
    - Callbacks are used to delay the execution of a function until a particular time or event has occurred
    - Nodejs has an asynchronous behaviour to prevent blocking of execution, ex- reading data from a file, fetching data from a database or handling a network request.


13. Built-in Module: events
- The events module allow us to work with events in nodejs
- An event is an action or an occurrence that has happened in our application that we can respond to
- Using the events module, we can dispatch our own custom events and respond to those custom events in a non-blocking manner
- The events module export an 'EventEmitter' class, and we can create an object of this class and use it in out file
- The object has 2 functions:
    - emitter.on() - to register an event
    - emitter.emit() - to make that event occur
- The on() function has an event-name as the first argument and the callBack as the second argument
- The emit() function has the event-name as the first argument and it can pass other arguments to further pass them to the callbacks in on() function
- Whenever the emit() function executes, the event described as first argument is occurred and the on() function which has the same event-name will execute the callback within it. 
- This EventEmitter class can be extended to another class and can be made use of the extended events functionality along with the functionality of the Child class